// This Pine Script™ code is subject to the terms of the Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © UAlgo
//@version=6
indicator('Price Action Volumetric Breaker Blocks [UAlgo]', shorttitle = '', overlay = true, max_lines_count = 500, max_labels_count = 500, max_bars_back = 2000)

swingLength = input.int(8, title = 'Swing Length', group = ' Settings', minval = 5)
showLastXBb = input.int(4, title = 'Show Last X Order Blocks', minval = 1, maxval = 10, group = ' Settings')
violationType = input.string('Wick', title = 'Violation Check', options = ['Wick', 'Close'], group = ' Settings')
hideOverlap = input.string('True', title = 'Hide Overlap', options = ['True', 'False'], group = ' Settings')
upBbColor = input.color(color.teal, title = 'Colors', group = ' Settings', inline = 'vs')
downBbColor = input.color(color.red, title = ' ', group = ' Settings', inline = 'vs')

type swing
	float y = na
	int x = na
	bool crossed = false

type bb
	float top = na
	float btm = na
	int barStart
	float bullishStr
	float bearishStr
	box bbBox
	box bullishBox
	box bearishBox
	float vol
	bool broken = false
	line seperatorLine
	line orderTextSeperator

type market
	string msbOrBos
	int direction
	line marketLine
	int lastLineTime
	label marketLabel

var array<bb> bullishBb = array.new<bb>()
var array<bb> bearishBb = array.new<bb>()
var market marketStructure = market.new(na, na, na, 0)

var float top = na
var float btm = na
top := ta.pivothigh(swingLength, swingLength)
btm := ta.pivotlow(swingLength, swingLength)


var swing topp = swing.new()
var swing btmm = swing.new()
if not na(top)
    topp.x := time[swingLength]
    topp.y := high[swingLength]
    topp.crossed := false
    topp.crossed

if not na(btm)
    btmm.x := time[swingLength]
    btmm.y := low[swingLength]
    btmm.crossed := false
    btmm.crossed
calculateStrengths(barIndex) =>
    float bullishStrength = 0.0
    float bearishStrength = 0.0
    int barsToConsider = swingLength

    for i = 0 to barsToConsider - 1 by 1
        if barIndex - i >= 0
            float openn = open[barIndex - i]
            float highh = high[barIndex - i]
            float loww = low[barIndex - i]
            float closee = close[barIndex - i]
            float volumee = volume[barIndex - i]

            if openn > closee
                bearishStrength := bearishStrength + volumee
                bearishStrength
            else
                bullishStrength := bullishStrength + volumee
                bullishStrength

    [bullishStrength, bearishStrength]

isOverlapping(newBlock, existingArray) =>
    bool flag = false
    if existingArray.size() > 0
        for i = 0 to existingArray.size() - 1 by 1
            existingBlock = array.get(existingArray, i)
            if newBlock.top >= existingBlock.btm and newBlock.top <= existingBlock.top or newBlock.btm >= existingBlock.btm and newBlock.btm <= existingBlock.top
                flag := true
                flag
    flag

drawBox(volatilityBlock) =>
    volatilityBlock.bullishBox := box.new(left = volatilityBlock.barStart, right = time, top = volatilityBlock.top, bottom = volatilityBlock.btm + (volatilityBlock.top - volatilityBlock.btm) / 2, bgcolor = color.new(upBbColor, 40), border_color = na, xloc = xloc.bar_time)

    volatilityBlock.bearishBox := box.new(left = volatilityBlock.barStart, right = time, top = volatilityBlock.btm + (volatilityBlock.top - volatilityBlock.btm) / 2, bottom = volatilityBlock.btm, bgcolor = color.new(downBbColor, 40), border_color = na, xloc = xloc.bar_time)

    volatilityBlock.bbBox := box.new(left = volatilityBlock.barStart, right = time, top = volatilityBlock.top, bottom = volatilityBlock.btm, bgcolor = color.new(color.gray, 80), border_color = na, xloc = xloc.bar_time)

    volatilityBlock.seperatorLine := line.new(x1 = volatilityBlock.barStart, y1 = volatilityBlock.btm + (volatilityBlock.top - volatilityBlock.btm) / 2, x2 = time, y2 = volatilityBlock.btm + (volatilityBlock.top - volatilityBlock.btm) / 2, color = color.new(color.gray, 50), width = 1, xloc = xloc.bar_time, style = line.style_dashed)
    volatilityBlock.orderTextSeperator := line.new(x1 = volatilityBlock.barStart, y1 = volatilityBlock.top, x2 = volatilityBlock.barStart, y2 = volatilityBlock.btm, color = color.new(color.gray, 50), xloc = xloc.bar_time, style = line.style_solid)
    volatilityBlock.orderTextSeperator

if close < btmm.y and btmm.crossed == false
    btmm.crossed := true
    marketStructure.msbOrBos := na(marketStructure.msbOrBos) ? 'msb' : marketStructure.direction == -1 ? 'bos' : 'msb'
    marketStructure.direction := -1
    lineColor = color.red
    marketStructure.marketLine := line.new(x1 = btmm.x, y1 = btmm.y, x2 = time, y2 = btmm.y, xloc = xloc.bar_time, color = lineColor)
    marketStructure.lastLineTime := btmm.x
    labelText = marketStructure.msbOrBos == 'msb' ? 'MSB' : 'BOS'
    labelX = math.round(math.avg(btmm.x, time))
    marketStructure.marketLabel := label.new(x = labelX, y = btmm.y, text = labelText, color = color.new(color.white, 100), textcolor = lineColor, style = label.style_label_up, xloc = xloc.bar_time, size = size.tiny)

    float highAndGreenTop = 0
    float highAndGreenBtm = 0
    int highAndGreenTime = 0
    int selectedIndex = 0
    float vol = na
    for i = 1 to (time - btmm.x) / (time - time[1]) by 1
        if close[i] > open[i] and high[i] > highAndGreenTop
            highAndGreenTop := high[i]
            highAndGreenBtm := low[i]
            highAndGreenTime := time[i]
            vol := volume[i]
            selectedIndex := i
            selectedIndex

    [bullishStrength, bearishStrength] = calculateStrengths(selectedIndex)

    newOb = bb.new(highAndGreenTop, highAndGreenBtm, highAndGreenTime)
    newOb.bullishStr := bullishStrength
    newOb.bearishStr := bearishStrength
    newOb.vol := vol
    newOb.broken := false

    if not isOverlapping(newOb, bearishBb) and hideOverlap == 'True'
        array.push(bearishBb, newOb)

    if hideOverlap == 'False'
        array.push(bearishBb, newOb)


    if array.size(bearishBb) > showLastXBb
        for i = 0 to array.size(bearishBb) - 1 by 1
            currentBb = array.get(bearishBb, i)
            if not na(currentBb.bbBox)
                oldOb = array.shift(bearishBb)
                box.delete(oldOb.bullishBox)
                box.delete(oldOb.bearishBox)
                box.delete(oldOb.bbBox)
                line.delete(oldOb.seperatorLine)
                line.delete(oldOb.orderTextSeperator)
                break

else if close > topp.y and topp.crossed == false
    topp.crossed := true
    marketStructure.msbOrBos := na(marketStructure.msbOrBos) ? 'msb' : marketStructure.direction == 1 ? 'bos' : 'msb'
    marketStructure.direction := 1
    lineColor = color.green
    marketStructure.marketLine := line.new(x1 = topp.x, y1 = topp.y, x2 = time, y2 = topp.y, xloc = xloc.bar_time, color = lineColor)
    marketStructure.lastLineTime := topp.x
    labelText = marketStructure.msbOrBos == 'msb' ? 'MSB' : 'BOS'
    labelX = math.round(math.avg(topp.x, time))
    marketStructure.marketLabel := label.new(x = labelX, y = topp.y, text = labelText, color = color.new(color.white, 100), textcolor = lineColor, style = label.style_label_down, xloc = xloc.bar_time, size = size.tiny)

    float lowAndRedBtm = 999999999999
    float lowAndRedTop = na
    int lowAndRedTime = 0
    int selectedIndex = 0
    float vol = na
    for i = 1 to (time - topp.x) / (time - time[1]) by 1
        if close[i] < open[i] and low[i] < lowAndRedBtm
            lowAndRedBtm := low[i]
            lowAndRedTop := high[i]
            lowAndRedTime := time[i]
            vol := volume[i]
            selectedIndex := i
            selectedIndex

    [bullishStrength, bearishStrength] = calculateStrengths(selectedIndex)

    newOb = bb.new(lowAndRedTop, lowAndRedBtm, lowAndRedTime)
    newOb.bullishStr := bullishStrength
    newOb.bearishStr := bearishStrength
    newOb.vol := vol
    newOb.broken := false

    if not isOverlapping(newOb, bullishBb) and hideOverlap == 'True'
        array.push(bullishBb, newOb)

    if hideOverlap == 'False'
        array.push(bullishBb, newOb)

    if array.size(bullishBb) > showLastXBb
        for i = 0 to array.size(bullishBb) - 1 by 1
            currentBb = array.get(bullishBb, i)
            if not na(currentBb.bbBox)
                oldOb = array.shift(bullishBb)
                box.delete(oldOb.bullishBox)
                box.delete(oldOb.bearishBox)
                box.delete(oldOb.bbBox)
                line.delete(oldOb.seperatorLine)
                line.delete(oldOb.orderTextSeperator)
                break
if array.size(bullishBb) > 0

    for i = 0 to array.size(bullishBb) - 1 by 1
        currentBb = array.get(bullishBb, i)
        if close[1] < currentBb.btm and currentBb.broken == false
            currentBb.broken := true
            drawBox(currentBb)
            break
        totalStr = currentBb.bullishStr + currentBb.bearishStr
        bullishBoxWidth = currentBb.bullishStr / totalStr * ((currentBb.bbBox.get_left() + time) / 2 - currentBb.barStart)
        bearishBoxWidth = currentBb.bearishStr / totalStr * ((currentBb.bbBox.get_left() + time) / 2 - currentBb.barStart)
        currentBb.bullishBox.set_right(math.round(currentBb.barStart + bullishBoxWidth))
        currentBb.bearishBox.set_right(math.round(currentBb.barStart + bearishBoxWidth))
        currentBb.bbBox.set_right(time)
        line.set_xy2(currentBb.seperatorLine, (currentBb.bbBox.get_left() + time) / 2, currentBb.btm + (currentBb.top - currentBb.btm) / 2)

        line.set_xy1(currentBb.orderTextSeperator, (currentBb.bbBox.get_left() + time) / 2, currentBb.top)
        line.set_xy2(currentBb.orderTextSeperator, (currentBb.bbBox.get_left() + time) / 2, currentBb.btm)


        violation = violationType == 'Wick' and high > currentBb.top or violationType == 'Close' and close > currentBb.top

        if violation and currentBb.broken
            box.delete(currentBb.bullishBox)
            box.delete(currentBb.bearishBox)
            box.delete(currentBb.bbBox)
            line.delete(currentBb.seperatorLine)
            line.delete(currentBb.orderTextSeperator)
            array.remove(bullishBb, i)
            break

if array.size(bearishBb) > 0
    for i = 0 to array.size(bearishBb) - 1 by 1
        currentBb = array.get(bearishBb, i)
        if close[1] > currentBb.top and currentBb.broken == false
            currentBb.broken := true
            drawBox(currentBb)
            break
        totalStr = currentBb.bullishStr + currentBb.bearishStr
        bullishBoxWidth = currentBb.bullishStr / totalStr * ((currentBb.bbBox.get_left() + time) / 2 - currentBb.barStart)
        bearishBoxWidth = currentBb.bearishStr / totalStr * ((currentBb.bbBox.get_left() + time) / 2 - currentBb.barStart)
        currentBb.bullishBox.set_right(math.round(currentBb.barStart + bullishBoxWidth))
        currentBb.bearishBox.set_right(math.round(currentBb.barStart + bearishBoxWidth))
        currentBb.bbBox.set_right(time)
        line.set_xy2(currentBb.seperatorLine, (currentBb.bbBox.get_left() + time) / 2, currentBb.btm + (currentBb.top - currentBb.btm) / 2)

        line.set_xy1(currentBb.orderTextSeperator, (currentBb.bbBox.get_left() + time) / 2, currentBb.top)
        line.set_xy2(currentBb.orderTextSeperator, (currentBb.bbBox.get_left() + time) / 2, currentBb.btm)



        violation = violationType == 'Wick' and low < currentBb.btm or violationType == 'Close' and close < currentBb.btm

        if violation and currentBb.broken
            box.delete(currentBb.bullishBox)
            box.delete(currentBb.bearishBox)
            box.delete(currentBb.bbBox)
            line.delete(currentBb.seperatorLine)
            line.delete(currentBb.orderTextSeperator)
            array.remove(bearishBb, i)
            break
